use bytes::BytesMut;
use tokio_io::codec::Encoder;

use io::MemcacheCodec;
use protocol::{Request, Command, extras};
use protocol::extras::Extras;

macro_rules! encode_and_compare {
    ($request:ident, $bytes:ident) => {
        let mut output = BytesMut::new();
        let mut codec = MemcacheCodec::new();

        let result = codec.encode($request, &mut output);
        assert!(result.is_ok());
        assert_eq!(output, $bytes);
    };
}

#[test]
fn test_get() {
    let request: Request = Request::build(Command::Get)
        .key(Some("Hello"))
        .finish();

    let expected: Vec<u8> = vec![
        0x80, 0x00, 0x00, 0x07,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x07,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x22, 0x48, 0x65, 0x6c,
        0x6c, 0x6f, 0x22,
    ];

    encode_and_compare!(request, expected);
}

#[test]
fn test_set() {
    let request = Request::build(Command::Set)
        .key(Some("Hello"))
        .value(Some("World"))
        .extras(Some(extras::Set::default().to_vec()))
        .finish();

    let expected: Vec<u8> = vec![
        0x80, 0x01, 0x00, 0x07,
        0x08, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x16,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x22, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x22, // key
        0x22, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x22, // value
    ];

    encode_and_compare!(request, expected);
}

//#[test]
//fn test_delete() {
//    let request = Request::build(Command::Delete)
//        .key(Some(b"Hello".to_vec()))
//        .finish();
//
//    let expected: Vec<u8> = vec![
//        0x80, 0x04, 0x00, 0x05,
//        0x00, 0x00, 0x00, 0x00,
//        0x00, 0x00, 0x00, 0x05,
//        0x00, 0x00, 0x00, 0x00,
//        0x00, 0x00, 0x00, 0x00,
//        0x00, 0x00, 0x00, 0x00,
//        0x48, 0x65, 0x6c, 0x6c,
//        0x6f,
//    ];
//
//    encode_and_compare!(request, expected);
//}

#[test]
fn test_quit() {
    let request: Request = Request::build(Command::Quit)
        .finish();

    let expected: Vec<u8> = vec![
        0x80, 0x07, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    encode_and_compare!(request, expected);
}

#[test]
fn test_noop() {
    let request: Request = Request::build(Command::Noop)
        .finish();

    let expected: Vec<u8> = vec![
        0x80, 0x0a, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    encode_and_compare!(request, expected);
}

#[test]
fn test_version() {
    let request: Request = Request::build(Command::Version)
        .finish();

    let expected: Vec<u8> = vec![
        0x80, 0x0b, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    encode_and_compare!(request, expected);
}
