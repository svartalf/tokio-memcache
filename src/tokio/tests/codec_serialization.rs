use bytes::BytesMut;
use tokio_io::codec::Encoder;
use tokio::MemcacheCodec;

use protocol::{Request, Command, extras};
use protocol::extras::Extras;

macro_rules! encode_and_compare {
    ($request:ident, $bytes:ident) => {
        let mut output = BytesMut::new();
        let mut codec = MemcacheCodec{};

        let result = codec.encode($request, &mut output);
        assert!(result.is_ok());
        assert_eq!(output, $bytes);
    };
}

#[test]
fn test_get() {
    let request: Request = Request::build(Command::Get)
        .key(Some(b"Hello".to_vec()))
        .finish();

    let expected: Vec<u8> = vec![
        0x80, 0x00, 0x00, 0x05,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x05,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x48, 0x65, 0x6c, 0x6c,
        0x6f,
    ];

    encode_and_compare!(request, expected);
}

#[test]
fn test_set() {
    let request = Request::build(Command::Set)
        .key(Some(b"Hello".to_vec()))
        .value(Some(b"World".to_vec()))
        .extras(Some(extras::Set::default().to_vec()))
        .finish();

    let expected: Vec<u8> = vec![
        0x80, 0x01, 0x00, 0x05,
        0x08, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x12,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x48, 0x65, 0x6c, 0x6c,
        0x6f, 0x57, 0x6f, 0x72,
        0x6c, 0x64,
    ];

    encode_and_compare!(request, expected);
}

#[test]
fn test_delete() {
    let request = Request::build(Command::Delete)
        .key(Some(b"Hello".to_vec()))
        .finish();

    let expected: Vec<u8> = vec![
        0x80, 0x04, 0x00, 0x05,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x05,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x48, 0x65, 0x6c, 0x6c,
        0x6f,
    ];

    encode_and_compare!(request, expected);
}

#[test]
fn test_quit() {
    let request = Request::build(Command::Quit)
        .finish();

    let expected: Vec<u8> = vec![
        0x80, 0x07, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    encode_and_compare!(request, expected);
}

#[test]
fn test_noop() {
    let request = Request::build(Command::Noop)
        .finish();

    let expected: Vec<u8> = vec![
        0x80, 0x0a, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    encode_and_compare!(request, expected);
}

#[test]
fn test_version() {
    let request = Request::build(Command::Version)
        .finish();

    let expected: Vec<u8> = vec![
        0x80, 0x0b, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    encode_and_compare!(request, expected);
}
